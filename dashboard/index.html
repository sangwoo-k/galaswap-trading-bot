<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GalaSwap Trading Bot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }

        .card h3 {
            color: #4a5568;
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-online {
            background-color: #48bb78;
            box-shadow: 0 0 10px rgba(72, 187, 120, 0.5);
        }

        .status-offline {
            background-color: #f56565;
            box-shadow: 0 0 10px rgba(245, 101, 101, 0.5);
        }

        .status-warning {
            background-color: #ed8936;
            box-shadow: 0 0 10px rgba(237, 137, 54, 0.5);
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-weight: 500;
            color: #4a5568;
        }

        .metric-value {
            font-weight: 600;
            color: #2d3748;
        }

        .metric-value.positive {
            color: #48bb78;
        }

        .metric-value.negative {
            color: #f56565;
        }

        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .strategy-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4299e1;
        }

        .strategy-item.enabled {
            border-left-color: #48bb78;
        }

        .strategy-item.disabled {
            border-left-color: #a0aec0;
        }

        .strategy-name {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .strategy-details {
            font-size: 0.9rem;
            color: #4a5568;
        }

        .transactions {
            max-height: 400px;
            overflow-y: auto;
        }

        .transaction-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #4299e1;
        }

        .transaction-item.success {
            border-left-color: #48bb78;
        }

        .transaction-item.error {
            border-left-color: #f56565;
        }

        .transaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .transaction-type {
            font-weight: 600;
            color: #2d3748;
        }

        .transaction-time {
            font-size: 0.9rem;
            color: #718096;
        }

        .transaction-details {
            font-size: 0.9rem;
            color: #4a5568;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #4299e1;
            color: white;
        }

        .btn-primary:hover {
            background: #3182ce;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #f56565;
            color: white;
        }

        .btn-danger:hover {
            background: #e53e3e;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
            transform: translateY(-2px);
        }

        .loading {
            text-align: center;
            color: #718096;
            font-style: italic;
        }

        .error {
            background: #fed7d7;
            color: #c53030;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .last-updated {
            text-align: center;
            color: #718096;
            font-size: 0.9rem;
            margin-top: 20px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        /* Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 300px;
            max-width: 400px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 5px solid #48bb78;
        }

        .notification.error {
            border-left: 5px solid #f56565;
        }

        .notification.info {
            border-left: 5px solid #4299e1;
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .notification-title {
            font-weight: 600;
            color: #2d3748;
            font-size: 1.1rem;
        }

        .notification-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #718096;
        }

        .notification-body {
            color: #4a5568;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .notification-time {
            color: #718096;
            font-size: 0.8rem;
            margin-top: 8px;
        }

        /* Transaction Alert Styles */
        .transaction-alert {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            animation: slideIn 0.5s ease;
        }

        .transaction-alert.error {
            background: linear-gradient(135deg, #f56565, #e53e3e);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Sound notification indicator */
        .sound-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4299e1;
            color: white;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 0.9rem;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sound-indicator.show {
            opacity: 1;
        }

        /* Risk Control Panel Styles */
        .risk-control-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-left: 4px solid #FF9800;
        }

        .risk-control-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }

        .risk-slider-container {
            margin-bottom: 20px;
        }

        .risk-slider-container label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        #riskSlider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        #riskSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #FF9800;
            cursor: pointer;
        }

        #riskSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #FF9800;
            cursor: pointer;
            border: none;
        }

        .risk-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }

        .risk-impact {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border-left: 3px solid #28a745;
        }

        .risk-impact p {
            margin: 0 0 10px 0;
            font-weight: bold;
            color: #333;
        }

        .risk-impact ul {
            margin: 0;
            padding-left: 20px;
        }

        .risk-impact li {
            margin-bottom: 5px;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 GalaSwap Trading Bot Dashboard</h1>
            <p>Real-time monitoring and transaction tracking</p>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="startBot()">Start Bot</button>
            <button class="btn btn-danger" onclick="stopBot()">Stop Bot</button>
            <button class="btn btn-success" onclick="refreshData()">Refresh</button>
            <button class="btn btn-primary" onclick="toggleAutoRefresh()">Auto Refresh: <span id="autoRefreshStatus">OFF</span></button>
            <button class="btn btn-primary" onclick="toggleNotifications()">Notifications: <span id="notificationStatus">ON</span></button>
            <button class="btn btn-primary" onclick="toggleSound()">Sound: <span id="soundStatus">ON</span></button>
                <button class="btn btn-success" onclick="simulateRealTransaction()">Test Real Transaction</button>
            </div>
            
            <!-- Risk Control Panel -->
            <div class="risk-control-panel">
                <h3>🎯 Risk Control</h3>
                <div class="risk-slider-container">
                    <label for="riskSlider">Risk Score: <span id="currentRiskScore">50</span>/100</label>
                    <input type="range" id="riskSlider" min="10" max="80" value="50" oninput="updateRiskScore(this.value)">
                    <div class="risk-labels">
                        <span>Conservative (10-30)</span>
                        <span>Moderate (40-60)</span>
                        <span>Aggressive (70-80)</span>
                    </div>
                </div>
                <div class="risk-impact">
                    <p><strong>Current Impact:</strong></p>
                    <ul>
                        <li>✅ More frequent trading opportunities</li>
                        <li>✅ Better capital utilization</li>
                        <li>⚠️ Higher position sizes</li>
                        <li>⚠️ More market exposure</li>
                    </ul>
                </div>
            </div>

        <div class="dashboard-grid">
            <!-- Bot Status Card -->
            <div class="card">
                <h3>
                    <span class="status-indicator" id="botStatus"></span>
                    Bot Status
                </h3>
                <div class="metric">
                    <span class="metric-label">Status</span>
                    <span class="metric-value" id="botStatusText">Checking...</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Uptime</span>
                    <span class="metric-value" id="botUptime">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Environment</span>
                    <span class="metric-value" id="botEnvironment">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Last Update</span>
                    <span class="metric-value" id="lastUpdate">-</span>
                </div>
            </div>

            <!-- Portfolio Overview Card -->
            <div class="card">
                <h3>📊 Portfolio Overview</h3>
                <div class="metric">
                    <span class="metric-label">Total Value</span>
                    <span class="metric-value" id="totalValue">$0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Positions</span>
                    <span class="metric-value" id="totalPositions">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Daily P&L</span>
                    <span class="metric-value" id="dailyPnL">$0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Win Rate</span>
                    <span class="metric-value" id="winRate">0%</span>
                </div>
            </div>

            <!-- Risk Metrics Card -->
            <div class="card">
                <h3>⚠️ Risk Metrics</h3>
                <div class="metric">
                    <span class="metric-label">Risk Score</span>
                    <span class="metric-value" id="riskScore">0/100</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Max Drawdown</span>
                    <span class="metric-value" id="maxDrawdown">0%</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Total Exposure</span>
                    <span class="metric-value" id="totalExposure">$0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Active Strategies</span>
                    <span class="metric-value" id="activeStrategies">0</span>
                </div>
            </div>

            <!-- Fee Monitoring Card -->
            <div class="card">
                <h3>💰 Fee Monitoring</h3>
                <div class="metric">
                    <span class="metric-label">GALA Fee</span>
                    <span class="metric-value" id="galaFee">1 GALA</span>
                </div>
                <div class="metric">
                    <span class="metric-label">GALA Price</span>
                    <span class="metric-value" id="galaPrice">$0.00</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Fee in USD</span>
                    <span class="metric-value" id="feeInUSD">$0.00</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Cache Status</span>
                    <span class="metric-value" id="cacheStatus">-</span>
                </div>
            </div>

            <!-- Live Token Prices Card -->
            <div class="card">
                <h3>📈 Live Token Prices (CoinGecko)</h3>
                <div id="tokenPricesList" class="strategy-grid">
                    <div class="loading">Loading prices...</div>
                </div>
            </div>

            <!-- Trading Strategies Card -->
            <div class="card">
                <h3>🎯 Trading Strategies</h3>
                <div id="strategiesList" class="strategy-grid">
                    <div class="loading">Loading strategies...</div>
                </div>
            </div>
        </div>

        <!-- Recent Transactions Card -->
        <div class="card">
            <h3>📈 Recent Transactions</h3>
            <div id="transactionsList" class="transactions">
                <div class="loading">Loading transactions...</div>
            </div>
        </div>

        <div class="last-updated" id="lastUpdated">
            Last updated: Never
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notificationContainer"></div>

    <!-- Sound Indicator -->
    <div class="sound-indicator" id="soundIndicator">
        🔊 Transaction Alert
    </div>

    <script>
        let autoRefreshInterval = null;
        let isAutoRefresh = false;
        let notificationsEnabled = true;
        let soundEnabled = true;
        let lastTransactionCount = 0;
        let transactionHistory = [];
        let tokenPrices = {};
        let lastPriceUpdate = 0;
        const PRICE_CACHE_DURATION = 60000; // 1 minute cache

        // Configuration
        const BOT_API_URL = 'http://localhost:3000';
        const REFRESH_INTERVAL = 5000; // 5 seconds
        const COINGECKO_API_URL = 'https://api.coingecko.com/api/v3';

        // Load current risk score from bot
        async function loadCurrentRiskScore() {
            try {
                const response = await fetch(`${BOT_API_URL}/risk/current`);
                if (response.ok) {
                    const riskData = await response.json();
                    document.getElementById('riskSlider').value = riskData.riskScore;
                    document.getElementById('currentRiskScore').textContent = riskData.riskScore;
                    
                    // Update impact description without sending to bot
                    updateRiskImpactDescription(riskData.riskScore);
                }
            } catch (error) {
                console.error('Error loading current risk score:', error);
            }
        }

        // Update risk impact description without API call
        function updateRiskImpactDescription(value) {
            const impactList = document.querySelector('.risk-impact ul');
            let impactItems = [];
            
            if (value <= 30) {
                impactItems = [
                    '✅ Conservative trading approach',
                    '✅ Lower position sizes (0.5x)',
                    '✅ Higher profit margins required',
                    '⚠️ Fewer trading opportunities (60s intervals)'
                ];
            } else if (value <= 60) {
                impactItems = [
                    '✅ More frequent trading opportunities',
                    '✅ Better capital utilization (1.0x positions)',
                    '⚠️ Moderate position sizes',
                    '⚠️ Balanced risk/reward (30s intervals)'
                ];
            } else {
                impactItems = [
                    '✅ Maximum trading frequency',
                    '✅ Aggressive capital deployment (1.5x positions)',
                    '⚠️ Higher position sizes',
                    '⚠️ Increased market exposure (15s intervals)'
                ];
            }
            
            impactList.innerHTML = impactItems.map(item => `<li>${item}</li>`).join('');
        }

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            refreshData();
            loadCurrentRiskScore();
            fetchTokenPrices(); // Initial price fetch
        });

        // Auto refresh toggle
        function toggleAutoRefresh() {
            isAutoRefresh = !isAutoRefresh;
            const statusElement = document.getElementById('autoRefreshStatus');
            
            if (isAutoRefresh) {
                statusElement.textContent = 'ON';
                statusElement.style.color = '#48bb78';
                autoRefreshInterval = setInterval(refreshData, REFRESH_INTERVAL);
            } else {
                statusElement.textContent = 'OFF';
                statusElement.style.color = '#f56565';
                clearInterval(autoRefreshInterval);
            }
        }

        // Notifications toggle
        function toggleNotifications() {
            notificationsEnabled = !notificationsEnabled;
            const statusElement = document.getElementById('notificationStatus');
            
            if (notificationsEnabled) {
                statusElement.textContent = 'ON';
                statusElement.style.color = '#48bb78';
            } else {
                statusElement.textContent = 'OFF';
                statusElement.style.color = '#f56565';
            }
        }

        // Sound toggle
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const statusElement = document.getElementById('soundStatus');
            
            if (soundEnabled) {
                statusElement.textContent = 'ON';
                statusElement.style.color = '#48bb78';
            } else {
                statusElement.textContent = 'OFF';
                statusElement.style.color = '#f56565';
            }
        }

        // Token mapping for CoinGecko API
        const TOKEN_MAPPING = {
            'GALA': 'gala',
            'ETH': 'ethereum',
            'BTC': 'bitcoin',
            'USDC': 'usd-coin',
            'USDT': 'tether',
            'BNB': 'binancecoin',
            'ADA': 'cardano',
            'SOL': 'solana',
            'MATIC': 'matic-network',
            'DOT': 'polkadot'
        };

        // Fetch token prices from CoinGecko
        async function fetchTokenPrices() {
            try {
                const now = Date.now();
                if (now - lastPriceUpdate < PRICE_CACHE_DURATION && Object.keys(tokenPrices).length > 0) {
                    return; // Use cached prices
                }

                const tokenIds = Object.values(TOKEN_MAPPING).join(',');
                const response = await fetch(`${COINGECKO_API_URL}/simple/price?ids=${tokenIds}&vs_currencies=usd&include_24hr_change=true`);
                
                if (!response.ok) {
                    throw new Error(`CoinGecko API error: ${response.status}`);
                }

                const data = await response.json();
                
                // Map CoinGecko data to our token symbols
                for (const [symbol, coinId] of Object.entries(TOKEN_MAPPING)) {
                    if (data[coinId]) {
                        tokenPrices[symbol] = {
                            price: data[coinId].usd,
                            change24h: data[coinId].usd_24h_change || 0,
                            lastUpdated: now
                        };
                    }
                }

                lastPriceUpdate = now;
                console.log('Token prices updated:', tokenPrices);
                
                // Update fee monitoring with real GALA price
                updateFeeMonitoringWithRealPrices();
                
            } catch (error) {
                console.error('Error fetching token prices:', error);
                // Use fallback prices if API fails
                if (Object.keys(tokenPrices).length === 0) {
                    tokenPrices = {
                        'GALA': { price: 0.05, change24h: 0, lastUpdated: Date.now() },
                        'ETH': { price: 2000, change24h: 0, lastUpdated: Date.now() },
                        'BTC': { price: 45000, change24h: 0, lastUpdated: Date.now() },
                        'USDC': { price: 1, change24h: 0, lastUpdated: Date.now() }
                    };
                }
            }
        }

        // Get token price with fallback
        function getTokenPrice(symbol) {
            if (tokenPrices[symbol]) {
                return tokenPrices[symbol].price;
            }
            // Fallback prices
            const fallbackPrices = {
                'GALA': 0.05,
                'ETH': 2000,
                'BTC': 45000,
                'USDC': 1,
                'USDT': 1
            };
            return fallbackPrices[symbol] || 0;
        }

        // Get token price change
        function getTokenPriceChange(symbol) {
            if (tokenPrices[symbol]) {
                return tokenPrices[symbol].change24h;
            }
            return 0;
        }

        // Refresh all data
        async function refreshData() {
            try {
                // Fetch prices first
                await fetchTokenPrices();
                
                await Promise.all([
                    updateBotStatus(),
                    updatePortfolioData(),
                    updateRiskMetrics(),
                    updateStrategies(),
                    updateTransactions(),
                    updateFeeMonitoringWithRealPrices(),
                    updateTokenPricesDisplay()
                ]);
                
                // Check for new transactions
                await checkForNewTransactions();
                
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${new Date().toLocaleTimeString()}`;
            } catch (error) {
                console.error('Error refreshing data:', error);
                showError('Failed to refresh data. Make sure the bot is running on port 3000.');
            }
        }

        // Update bot status
        async function updateBotStatus() {
            try {
                const response = await fetch(`${BOT_API_URL}/health`);
                const data = await response.json();
                
                const statusIndicator = document.getElementById('botStatus');
                const statusText = document.getElementById('botStatusText');
                const uptime = document.getElementById('botUptime');
                const environment = document.getElementById('botEnvironment');
                
                if (data.status === 'healthy') {
                    statusIndicator.className = 'status-indicator status-online';
                    statusText.textContent = 'Online';
                    statusText.className = 'metric-value positive';
                } else {
                    statusIndicator.className = 'status-indicator status-warning';
                    statusText.textContent = data.status;
                    statusText.className = 'metric-value';
                }
                
                uptime.textContent = formatUptime(data.uptime);
                environment.textContent = data.environment || 'development';
                
            } catch (error) {
                const statusIndicator = document.getElementById('botStatus');
                const statusText = document.getElementById('botStatusText');
                
                statusIndicator.className = 'status-indicator status-offline';
                statusText.textContent = 'Offline';
                statusText.className = 'metric-value negative';
            }
        }

        // Update portfolio data
        async function updatePortfolioData() {
            try {
                // Get config data for portfolio info
                const configResponse = await fetch(`${BOT_API_URL}/config`);
                const configData = await configResponse.json();
                
                // Calculate portfolio value with real USD prices
                const galaAmount = 2000; // Your 2000 GALA funding (500 + 1500)
                const galaPrice = getTokenPrice('GALA');
                const totalValueUSD = galaAmount * galaPrice;
                const totalPositions = 2; // arbitrage and momentum strategies
                
                document.getElementById('totalValue').textContent = 
                    `$${totalValueUSD.toLocaleString(2)} (${galaAmount} GALA)`;
                document.getElementById('totalPositions').textContent = 
                    totalPositions;
                
                // Calculate daily P&L from transaction history
                const dailyPnL = calculateDailyPnL();
                const dailyPnLElement = document.getElementById('dailyPnL');
                const winRate = calculateWinRate();
                
                dailyPnLElement.textContent = `$${dailyPnL.toFixed(2)}`;
                dailyPnLElement.className = dailyPnL >= 0 ? 'metric-value positive' : 'metric-value negative';
                
                document.getElementById('winRate').textContent = `${winRate.toFixed(1)}%`;
                
            } catch (error) {
                console.error('Error updating portfolio data:', error);
                // Set default values
                const galaPrice = getTokenPrice('GALA');
                const totalValueUSD = 2000 * galaPrice;
                document.getElementById('totalValue').textContent = `$${totalValueUSD.toFixed(2)} (2000 GALA)`;
                document.getElementById('totalPositions').textContent = '2';
                document.getElementById('dailyPnL').textContent = '$0.00';
                document.getElementById('winRate').textContent = '0%';
            }
        }

        // Calculate daily P&L from transaction history
        function calculateDailyPnL() {
            const today = new Date().toDateString();
            let totalPnL = 0;
            
            transactionHistory.forEach(tx => {
                const txDate = new Date(tx.timestamp).toDateString();
                if (txDate === today) {
                    const galaPrice = getTokenPrice('GALA');
                    totalPnL += parseFloat(tx.profit) * galaPrice;
                }
            });
            
            return totalPnL;
        }

        // Calculate win rate
        function calculateWinRate() {
            if (transactionHistory.length === 0) return 0;
            
            const winningTrades = transactionHistory.filter(tx => parseFloat(tx.profit) > 0).length;
            return (winningTrades / transactionHistory.length) * 100;
        }

        // Update risk metrics
        async function updateRiskMetrics() {
            try {
                // Get status data for risk metrics
                const statusResponse = await fetch(`${BOT_API_URL}/status`);
                const statusData = await statusResponse.json();
                
                // Get actual risk score from bot
                let riskScore = 0;
                try {
                    const riskResponse = await fetch(`${BOT_API_URL}/risk/current`);
                    if (riskResponse.ok) {
                        const riskData = await riskResponse.json();
                        riskScore = riskData.riskScore;
                    }
                } catch (error) {
                    console.error('Error fetching risk data:', error);
                    riskScore = statusData.isRunning ? 50 : 0; // Fallback
                }
                const maxDrawdown = 0; // No drawdown yet
                const totalExposure = 2000; // Your 2000 GALA funding
                const activeStrategies = statusData.strategies ? statusData.strategies.length : 2;
                
                document.getElementById('riskScore').textContent = 
                    `${riskScore}/100`;
                document.getElementById('maxDrawdown').textContent = 
                    `${maxDrawdown}%`;
                document.getElementById('totalExposure').textContent = 
                    `${totalExposure} GALA`;
                document.getElementById('activeStrategies').textContent = 
                    activeStrategies;
                
            } catch (error) {
                console.error('Error updating risk metrics:', error);
                // Set default values
                document.getElementById('riskScore').textContent = '0/100';
                document.getElementById('maxDrawdown').textContent = '0%';
                document.getElementById('totalExposure').textContent = '2000 GALA';
                document.getElementById('activeStrategies').textContent = '2';
            }
        }

        // Update strategies
        async function updateStrategies() {
            try {
                // Get status data for strategies
                const statusResponse = await fetch(`${BOT_API_URL}/status`);
                const statusData = await statusResponse.json();
                
                const strategiesList = document.getElementById('strategiesList');
                
                if (statusData.strategies && statusData.strategies.length > 0) {
                    strategiesList.innerHTML = statusData.strategies.map(strategy => `
                        <div class="strategy-item ${statusData.isRunning ? 'enabled' : 'disabled'}">
                            <div class="strategy-name">${strategy}</div>
                            <div class="strategy-details">
                                Status: ${statusData.isRunning ? 'Active' : 'Inactive'}<br>
                                Risk: Medium<br>
                                Positions: 0
                            </div>
                        </div>
                    `).join('');
                } else {
                    strategiesList.innerHTML = '<div class="loading">No strategies found</div>';
                }
                
            } catch (error) {
                console.error('Error updating strategies:', error);
                // Set default strategies
                const strategiesList = document.getElementById('strategiesList');
                strategiesList.innerHTML = `
                    <div class="strategy-item disabled">
                        <div class="strategy-name">Arbitrage</div>
                        <div class="strategy-details">
                            Status: Inactive<br>
                            Risk: Medium<br>
                            Positions: 0
                        </div>
                    </div>
                    <div class="strategy-item disabled">
                        <div class="strategy-name">Momentum</div>
                        <div class="strategy-details">
                            Status: Inactive<br>
                            Risk: Medium<br>
                            Positions: 0
                        </div>
                    </div>
                `;
            }
        }

        // Update fee monitoring with real prices
        async function updateFeeMonitoringWithRealPrices() {
            try {
                const flatGalaFee = 1; // 1 GALA fee per transaction
                const galaPrice = getTokenPrice('GALA');
                const galaPriceChange = getTokenPriceChange('GALA');
                const feeInUSD = flatGalaFee * galaPrice;
                
                document.getElementById('galaFee').textContent = `${flatGalaFee} GALA`;
                
                // Show price with 24h change
                const priceChangeText = galaPriceChange >= 0 ? 
                    `$${galaPrice.toFixed(4)} (+${galaPriceChange.toFixed(2)}%)` :
                    `$${galaPrice.toFixed(4)} (${galaPriceChange.toFixed(2)}%)`;
                
                document.getElementById('galaPrice').textContent = priceChangeText;
                document.getElementById('galaPrice').className = galaPriceChange >= 0 ? 
                    'metric-value positive' : 'metric-value negative';
                
                document.getElementById('feeInUSD').textContent = `$${feeInUSD.toFixed(2)}`;
                
                // Show cache status
                const cacheAge = Date.now() - lastPriceUpdate;
                const cacheStatus = cacheAge < PRICE_CACHE_DURATION ? 
                    `Live (${Math.round(cacheAge/1000)}s ago)` : 'Stale';
                document.getElementById('cacheStatus').textContent = cacheStatus;
                
            } catch (error) {
                console.error('Error updating fee monitoring:', error);
                // Set default values
                document.getElementById('galaFee').textContent = '1 GALA';
                document.getElementById('galaPrice').textContent = '$0.0500';
                document.getElementById('feeInUSD').textContent = '$0.05';
                document.getElementById('cacheStatus').textContent = 'Error';
            }
        }

        // Update token prices display
        function updateTokenPricesDisplay() {
            try {
                const tokenPricesList = document.getElementById('tokenPricesList');
                const tokensToShow = ['GALA', 'ETH', 'BTC', 'USDC', 'USDT'];
                
                if (Object.keys(tokenPrices).length > 0) {
                    tokenPricesList.innerHTML = tokensToShow.map(symbol => {
                        const price = getTokenPrice(symbol);
                        const change = getTokenPriceChange(symbol);
                        const changeClass = change >= 0 ? 'positive' : 'negative';
                        const changeSymbol = change >= 0 ? '+' : '';
                        
                        return `
                            <div class="strategy-item">
                                <div class="strategy-name">${symbol}</div>
                                <div class="strategy-details">
                                    Price: $${price.toFixed(4)}<br>
                                    24h: <span class="metric-value ${changeClass}">${changeSymbol}${change.toFixed(2)}%</span>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    tokenPricesList.innerHTML = '<div class="loading">Loading prices from CoinGecko...</div>';
                }
            } catch (error) {
                console.error('Error updating token prices display:', error);
                document.getElementById('tokenPricesList').innerHTML = '<div class="loading">Error loading prices</div>';
            }
        }

        // Update transactions
        async function updateTransactions() {
            try {
                // Use the new transaction list function
                updateTransactionList();
            } catch (error) {
                console.error('Error updating transactions:', error);
            }
        }


        // Utility functions
        function formatUptime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hours}h ${minutes}m ${secs}s`;
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.dashboard-grid'));
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        // Notification functions
        function showNotification(title, message, type = 'info', duration = 5000) {
            if (!notificationsEnabled) return;

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            
            notification.innerHTML = `
                <div class="notification-header">
                    <div class="notification-title">${title}</div>
                    <button class="notification-close" onclick="closeNotification(this)">&times;</button>
                </div>
                <div class="notification-body">${message}</div>
                <div class="notification-time">${new Date().toLocaleTimeString()}</div>
            `;

            document.getElementById('notificationContainer').appendChild(notification);

            // Show notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            // Auto-remove notification
            setTimeout(() => {
                closeNotification(notification.querySelector('.notification-close'));
            }, duration);
        }

        function closeNotification(closeButton) {
            const notification = closeButton.closest('.notification');
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }

        // Sound notification
        function playNotificationSound() {
            if (!soundEnabled) return;

            // Show sound indicator
            const soundIndicator = document.getElementById('soundIndicator');
            soundIndicator.classList.add('show');
            
            // Play notification sound (using Web Audio API)
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.setValueAtTime(600, audioContext.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log('Could not play notification sound:', error);
            }

            // Hide sound indicator after 2 seconds
            setTimeout(() => {
                soundIndicator.classList.remove('show');
            }, 2000);
        }

        // Transaction monitoring - Only real bot activity
        async function checkForNewTransactions() {
            try {
                // Check for actual bot transactions (in a real implementation, this would check actual transaction logs)
                const currentTime = Date.now();
                const botStatus = await fetch(`${BOT_API_URL}/status`).then(r => r.json());
                
                // Only monitor when bot is actually running
                if (botStatus.isRunning) {
                    // In a real implementation, you would check:
                    // 1. Bot's transaction logs
                    // 2. Blockchain transaction history
                    // 3. Exchange API for executed trades
                    // 4. Smart contract events
                    
                    // For now, we'll only show notifications for actual bot state changes
                    // and real trading activity when it occurs
                    
                    // Example: Check if bot has executed any real trades
                    // This would be replaced with actual transaction detection logic
                    const hasRealTransactions = false; // Set to true when real transactions are detected
                    
                    if (hasRealTransactions) {
                        // Only show notifications for actual transactions
                        const transaction = {
                            id: Date.now(),
                            type: 'Real Trade',
                            token: 'GALA',
                            amount: '100.00',
                            amountUSD: 5.00,
                            profit: '1.50',
                            profitUSD: 0.075,
                            tokenPrice: 0.05,
                            timestamp: currentTime,
                            isReal: true
                        };

                        // Add to transaction history
                        transactionHistory.unshift(transaction);
                        if (transactionHistory.length > 50) {
                            transactionHistory = transactionHistory.slice(0, 50);
                        }

                        // Show notification for real transaction
                        showNotification(
                            '🔄 Real Transaction Executed',
                            `${transaction.type} ${transaction.amount} ${transaction.token} ($${transaction.amountUSD.toFixed(2)})<br>Profit: ${transaction.profit} GALA ($${transaction.profitUSD.toFixed(2)})`,
                            'success',
                            8000
                        );

                        // Play sound
                        playNotificationSound();

                        // Update transaction list
                        updateTransactionList();
                    }
                }
            } catch (error) {
                console.error('Error checking for new transactions:', error);
            }
        }

        function updateTransactionList() {
            const transactionsList = document.getElementById('transactionsList');
            
            // Filter to show only real transactions
            const realTransactions = transactionHistory.filter(tx => tx.isReal === true);
            
            if (realTransactions.length > 0) {
                transactionsList.innerHTML = realTransactions.slice(0, 10).map(tx => {
                    const profitClass = parseFloat(tx.profit) > 0 ? 'positive' : 'negative';
                    return `
                        <div class="transaction-item success">
                            <div class="transaction-header">
                                <span class="transaction-type">✅ ${tx.type} - ${tx.token}</span>
                                <span class="transaction-time">${new Date(tx.timestamp).toLocaleTimeString()}</span>
                            </div>
                            <div class="transaction-details">
                                Amount: ${tx.amount} ${tx.token} ($${tx.amountUSD ? tx.amountUSD.toFixed(2) : '0.00'})<br>
                                Profit: ${tx.profit} GALA ($${tx.profitUSD ? tx.profitUSD.toFixed(2) : '0.00'})<br>
                                ${tx.token} Price: $${tx.tokenPrice ? tx.tokenPrice.toFixed(4) : '0.0000'}<br>
                                <strong>Status: Real Transaction</strong>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                transactionsList.innerHTML = `
                    <div class="transaction-item">
                        <div class="transaction-header">
                            <span class="transaction-type">🔍 Monitoring Real Activity</span>
                            <span class="transaction-time">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="transaction-details">
                            Bot is monitoring markets for trading opportunities<br>
                            <strong>Only real transactions will be shown here</strong><br>
                            Real-time prices synced with CoinGecko<br>
                            <em>No simulated transactions - only your actual trading activity</em>
                        </div>
                    </div>
                `;
            }
        }

        // Simulate a real transaction for testing
        function simulateRealTransaction() {
            const currentTime = Date.now();
            const transactionTypes = ['Buy', 'Sell', 'Arbitrage', 'Momentum Trade'];
            const tokens = ['GALA', 'ETH', 'BTC', 'USDC'];
            const type = transactionTypes[Math.floor(Math.random() * transactionTypes.length)];
            const token = tokens[Math.floor(Math.random() * tokens.length)];
            const amount = (Math.random() * 100 + 10).toFixed(2);
            const profit = (Math.random() * 5 + 1).toFixed(2);
            
            // Calculate USD values
            const tokenPrice = getTokenPrice(token);
            const galaPrice = getTokenPrice('GALA');
            const amountUSD = parseFloat(amount) * tokenPrice;
            const profitUSD = parseFloat(profit) * galaPrice;
            
            const transaction = {
                id: Date.now(),
                type: type,
                token: token,
                amount: amount,
                amountUSD: amountUSD,
                profit: profit,
                profitUSD: profitUSD,
                tokenPrice: tokenPrice,
                timestamp: currentTime,
                isReal: true // Mark as real transaction
            };

            // Add to transaction history
            transactionHistory.unshift(transaction);
            if (transactionHistory.length > 50) {
                transactionHistory = transactionHistory.slice(0, 50);
            }

            // Show notification for real transaction
            showNotification(
                '🔄 Real Transaction Executed',
                `${type} ${amount} ${token} ($${amountUSD.toFixed(2)})<br>Profit: ${profit} GALA ($${profitUSD.toFixed(2)})`,
                'success',
                8000
            );

            // Play sound
            playNotificationSound();

            // Update transaction list
            updateTransactionList();
        }

        // Update risk score dynamically and send to bot
        async function updateRiskScore(value) {
            document.getElementById('currentRiskScore').textContent = value;
            
            // Update risk impact description based on score
            const impactList = document.querySelector('.risk-impact ul');
            let impactItems = [];
            
            if (value <= 30) {
                impactItems = [
                    '✅ Conservative trading approach',
                    '✅ Lower position sizes (0.5x)',
                    '✅ Higher profit margins required',
                    '⚠️ Fewer trading opportunities (60s intervals)'
                ];
            } else if (value <= 60) {
                impactItems = [
                    '✅ More frequent trading opportunities',
                    '✅ Better capital utilization (1.0x positions)',
                    '⚠️ Moderate position sizes',
                    '⚠️ Balanced risk/reward (30s intervals)'
                ];
            } else {
                impactItems = [
                    '✅ Maximum trading frequency',
                    '✅ Aggressive capital deployment (1.5x positions)',
                    '⚠️ Higher position sizes',
                    '⚠️ Increased market exposure (15s intervals)'
                ];
            }
            
            impactList.innerHTML = impactItems.map(item => `<li>${item}</li>`).join('');
            
            // Send risk score to bot API
            try {
                const response = await fetch(`${BOT_API_URL}/risk/update`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ riskScore: parseInt(value) })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    showNotification('Risk Score Updated', `Bot risk level set to ${value}/100<br>Trading frequency: ${result.tradingFrequency/1000}s<br>Position multiplier: ${result.positionSizeMultiplier}x`, 'success', 6000);
                    
                    // Update bot status display
                    setTimeout(() => {
                        refreshData();
                    }, 1000);
                } else {
                    const error = await response.json();
                    showNotification('Risk Update Failed', error.error || 'Failed to update risk score', 'error');
                }
            } catch (error) {
                console.error('Error updating risk score:', error);
                showNotification('Risk Update Failed', 'Could not connect to bot API', 'error');
            }
        }

        // Enhanced bot control functions with notifications
        async function startBot() {
            try {
                const response = await fetch(`${BOT_API_URL}/start`, {
                    method: 'POST'
                });
                
                let message;
                if (response.ok) {
                    try {
                        const data = await response.json();
                        message = data.message;
                    } catch (jsonError) {
                        const textResponse = await response.text();
                        message = textResponse || 'Bot started successfully';
                    }
                } else {
                    const textResponse = await response.text();
                    message = textResponse || 'Failed to start bot';
                }
                
                // Show notification
                showNotification('🤖 Bot Started', message, 'success', 5000);
                playNotificationSound();
                
                refreshData();
            } catch (error) {
                showNotification('❌ Error', 'Error starting bot: ' + error.message, 'error', 5000);
            }
        }

        async function stopBot() {
            try {
                const response = await fetch(`${BOT_API_URL}/stop`, {
                    method: 'POST'
                });
                
                let message;
                if (response.ok) {
                    try {
                        const data = await response.json();
                        message = data.message;
                    } catch (jsonError) {
                        const textResponse = await response.text();
                        message = textResponse || 'Bot stopped successfully';
                    }
                } else {
                    const textResponse = await response.text();
                    message = textResponse || 'Failed to stop bot';
                }
                
                // Show notification
                showNotification('🛑 Bot Stopped', message, 'info', 5000);
                playNotificationSound();
                
                refreshData();
            } catch (error) {
                showNotification('❌ Error', 'Error stopping bot: ' + error.message, 'error', 5000);
            }
        }
    </script>
</body>
</html>
